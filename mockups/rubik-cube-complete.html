<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Rubik - Josevi P√©rez</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #cubeView {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .scene {
            width: 600px;
            height: 600px;
            perspective: 1500px;
        }

        .cube-container {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.3s ease;
        }

        .cube-face {
            position: absolute;
            width: 360px;
            height: 360px;
            background: #000;
            border: 10px solid #1a1a1a;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            padding: 5px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
            backface-visibility: visible;
            transform-style: preserve-3d;
        }

        .face-front  { transform: translateZ(180px); }
        .face-back   { transform: rotateY(180deg) translateZ(180px); }
        .face-right  { transform: rotateY(90deg) translateZ(180px); }
        .face-left   { transform: rotateY(-90deg) translateZ(180px); }
        .face-top    { transform: rotateX(90deg) translateZ(180px); }
        .face-bottom { transform: rotateX(-90deg) translateZ(180px); }

        /* Animaci√≥n de rotaci√≥n de capa */
        .cube-face.rotating {
            animation: layerRotate 0.4s ease-out;
        }

        @keyframes layerRotate {
            0% { transform: var(--start-transform); }
            100% { transform: var(--end-transform); }
        }

        .sticker {
            border: 3px solid #1a1a1a;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .sticker:hover {
            transform: scale(0.95);
            filter: brightness(1.2);
        }

        .sticker.highlight {
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.9);
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(0.95); }
        }

        .color-red { background: #B71234; }
        .color-blue { background: #0046AD; }
        .color-green { background: #009B48; }
        .color-yellow { background: #FFD500; }
        .color-orange { background: #FF5800; }
        .color-white { background: #FFFFFF; }

        /* Stats Panel */
        .stats-panel {
            position: fixed;
            left: 20px;
            top: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 1.5rem;
            color: white;
            z-index: 100;
            min-width: 220px;
        }

        .stat-item { margin-bottom: 1.2rem; }
        .stat-item:last-child { margin-bottom: 0; }

        .stat-label {
            font-size: 0.75rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.3rem;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .timer-value { color: #FFD500; }
        .moves-value { color: #00ff88; }

        .status-value {
            font-size: 1rem;
            padding: 0.6rem;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
        }

        .status-solved {
            color: #FFD500;
            animation: solved-pulse 1s ease-in-out infinite;
        }

        @keyframes solved-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* History Panel */
        .history-panel {
            position: fixed;
            right: 20px;
            top: 20px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 1.5rem;
            color: white;
            z-index: 100;
            max-width: 280px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .history-title {
            font-size: 0.85rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            text-align: center;
            font-weight: 600;
        }

        .history-list {
            list-style: none;
            margin-bottom: 1rem;
        }

        .history-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.6rem 1rem;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: 'Courier New', monospace;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .history-item .move-notation {
            font-weight: bold;
            color: #00ff88;
        }

        .history-item .move-number {
            opacity: 0.6;
            font-size: 0.85rem;
        }

        .action-btn {
            width: 100%;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            color: white;
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 0.75rem;
        }

        .action-btn:last-child { margin-bottom: 0; }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }

        .shuffle-btn {
            background: rgba(255, 215, 0, 0.25);
            border-color: rgba(255, 215, 0, 0.6);
        }

        .undo-btn {
            background: rgba(255, 100, 100, 0.25);
            border-color: rgba(255, 100, 100, 0.6);
        }

        /* Mini Cube Indicator */
        .mini-cube {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            perspective: 500px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mini-cube-container {
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            animation: miniCubeSpin 20s linear infinite;
        }

        @keyframes miniCubeSpin {
            0% { transform: rotateX(-25deg) rotateY(-35deg); }
            100% { transform: rotateX(-25deg) rotateY(325deg); }
        }

        .mini-face {
            position: absolute;
            width: 60%;
            height: 60%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 1px;
            left: 20%;
            top: 20%;
        }

        .mini-sticker {
            border: 1px solid #000;
        }

        .mini-front  { transform: translateZ(30%); }
        .mini-back   { transform: rotateY(180deg) translateZ(30%); }
        .mini-right  { transform: rotateY(90deg) translateZ(30%); }
        .mini-left   { transform: rotateY(-90deg) translateZ(30%); }
        .mini-top    { transform: rotateX(90deg) translateZ(30%); }
        .mini-bottom { transform: rotateX(-90deg) translateZ(30%); }

        /* Drag Arrow Indicator */
        .drag-arrow {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            font-size: 3rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .drag-arrow.active {
            opacity: 0.8;
            animation: arrowPulse 0.5s ease-in-out infinite;
        }

        @keyframes arrowPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .help-hint {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1.2rem 2.5rem;
            border-radius: 50px;
            font-size: 1rem;
            opacity: 0;
            animation: fadeInOut 8s ease-in-out 2s;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 1; }
        }

        @media (max-width: 768px) {
            .scene { width: 350px; height: 350px; }
            .cube-face { width: 210px; height: 210px; }
            .face-front, .face-back, .face-right, .face-left, .face-top, .face-bottom { transform: translateZ(105px); }
            .face-back { transform: rotateY(180deg) translateZ(105px); }
            .face-right { transform: rotateY(90deg) translateZ(105px); }
            .face-left { transform: rotateY(-90deg) translateZ(105px); }
            .face-top { transform: rotateX(90deg) translateZ(105px); }
            .face-bottom { transform: rotateX(-90deg) translateZ(105px); }
            .stats-panel, .history-panel, .mini-cube {
                left: 10px;
                right: 10px;
                max-width: calc(100% - 20px);
            }
            .history-panel { top: auto; bottom: 10px; }
            .mini-cube { display: none; }
        }
    </style>
</head>
<body>
    <div id="cubeView">
        <div class="scene">
            <div class="cube-container" id="cube"></div>
        </div>
    </div>

    <div class="stats-panel">
        <div class="stat-item">
            <div class="stat-label">‚è±Ô∏è Tiempo</div>
            <div class="stat-value timer-value" id="timer">00:00</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">üéØ Movimientos</div>
            <div class="stat-value moves-value" id="moves">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Estado</div>
            <div class="status-value" id="status">Listo</div>
        </div>
    </div>

    <div class="history-panel">
        <div class="history-title">üìú Historial de Movimientos</div>
        <ul class="history-list" id="historyList"></ul>
        <button class="action-btn undo-btn" onclick="undoMove()">‚Ü∂ Deshacer</button>
        <button class="action-btn shuffle-btn" onclick="shuffleCube()">üé≤ Mezclar</button>
        <button class="action-btn" onclick="resetCube()">‚Ü∫ Reset</button>
    </div>

    <div class="mini-cube">
        <div class="mini-cube-container" id="miniCube"></div>
    </div>

    <div class="drag-arrow" id="dragArrow">‚Üí</div>

    <div class="help-hint">
        üéÆ Click y arrastra filas/columnas | Ver historial a la derecha | Mini-cubo abajo
    </div>

    <script>
        const cubeState = {
            F: Array(9).fill('red'),
            B: Array(9).fill('orange'),
            R: Array(9).fill('blue'),
            L: Array(9).fill('green'),
            U: Array(9).fill('yellow'),
            D: Array(9).fill('white')
        };

        const SOLVED_STATE = JSON.parse(JSON.stringify(cubeState));
        const moveHistory = [];

        const cube = document.getElementById('cube');
        const miniCube = document.getElementById('miniCube');
        const historyList = document.getElementById('historyList');
        const dragArrow = document.getElementById('dragArrow');

        let currentRotationX = -25;
        let currentRotationY = -35;
        let moves = 0;
        let seconds = 0;
        let timerInterval = null;
        let isPlaying = false;

        let isDraggingLayer = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let draggedSticker = null;

        function createCube(container, isMini = false) {
            const faces = ['F', 'B', 'R', 'L', 'U', 'D'];
            const classes = ['front', 'back', 'right', 'left', 'top', 'bottom'];

            faces.forEach((face, idx) => {
                const faceDiv = document.createElement('div');
                faceDiv.className = isMini ? `mini-face mini-${classes[idx]}` : `cube-face face-${classes[idx]}`;
                faceDiv.dataset.face = face;

                for (let i = 0; i < 9; i++) {
                    const sticker = document.createElement('div');
                    sticker.className = isMini ? 'mini-sticker' : 'sticker';
                    sticker.dataset.pos = i;
                    if (!isMini) {
                        sticker.addEventListener('mousedown', onStickerMouseDown);
                    }
                    faceDiv.appendChild(sticker);
                }

                container.appendChild(faceDiv);
            });
        }

        function updateCubeUI(container = cube, state = cubeState) {
            Object.keys(state).forEach(faceName => {
                const faceElement = container.querySelector(`[data-face="${faceName}"]`);
                const stickers = faceElement.querySelectorAll(container === miniCube ? '.mini-sticker' : '.sticker');
                state[faceName].forEach((color, index) => {
                    stickers[index].className = (container === miniCube ? 'mini-sticker' : 'sticker') + ` color-${color}`;
                    stickers[index].dataset.pos = index;
                });
            });
        }

        function onStickerMouseDown(e) {
            e.preventDefault();
            isDraggingLayer = true;
            draggedSticker = e.target;
            dragStartX = e.clientX;
            dragStartY = e.clientY;

            const pos = parseInt(draggedSticker.dataset.pos);
            highlightLayer(draggedSticker.closest('.cube-face'), pos);
        }

        function highlightLayer(face, pos) {
            const stickers = face.querySelectorAll('.sticker');
            const row = Math.floor(pos / 3);
            const col = pos % 3;

            stickers.forEach((sticker, index) => {
                const stickerRow = Math.floor(index / 3);
                const stickerCol = index % 3;
                if (stickerRow === row || stickerCol === col) {
                    sticker.classList.add('highlight');
                }
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.sticker').forEach(s => s.classList.remove('highlight'));
        }

        document.addEventListener('mousemove', (e) => {
            if (isDraggingLayer && draggedSticker) {
                const deltaX = e.clientX - dragStartX;
                const deltaY = e.clientY - dragStartY;

                // Mostrar flecha direccional
                updateDragArrow(e.clientX, e.clientY, deltaX, deltaY);

                const threshold = 60;
                if (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold) {
                    executeDragRotation(deltaX, deltaY);
                    isDraggingLayer = false;
                    draggedSticker = null;
                    clearHighlights();
                    dragArrow.classList.remove('active');
                }
            }
        });

        document.addEventListener('mouseup', () => {
            isDraggingLayer = false;
            draggedSticker = null;
            clearHighlights();
            dragArrow.classList.remove('active');
        });

        function updateDragArrow(x, y, deltaX, deltaY) {
            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);

            if (absX > 20 || absY > 20) {
                dragArrow.classList.add('active');
                dragArrow.style.left = x + 'px';
                dragArrow.style.top = y + 'px';

                if (absX > absY) {
                    dragArrow.textContent = deltaX > 0 ? '‚Üí' : '‚Üê';
                } else {
                    dragArrow.textContent = deltaY > 0 ? '‚Üì' : '‚Üë';
                }
            } else {
                dragArrow.classList.remove('active');
            }
        }

        function executeDragRotation(deltaX, deltaY) {
            if (!draggedSticker) return;

            const face = draggedSticker.closest('.cube-face').dataset.face;
            const pos = parseInt(draggedSticker.dataset.pos);
            const row = Math.floor(pos / 3);
            const col = pos % 3;

            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);
            const horizontal = absX > absY;

            let moveToExecute = null;
            let counterClockwise = false;

            if (face === 'F') {
                if (horizontal) {
                    if (row === 0) { moveToExecute = 'U'; counterClockwise = deltaX < 0; }
                    else if (row === 2) { moveToExecute = 'D'; counterClockwise = deltaX > 0; }
                } else {
                    if (col === 0) { moveToExecute = 'L'; counterClockwise = deltaY > 0; }
                    else if (col === 2) { moveToExecute = 'R'; counterClockwise = deltaY < 0; }
                }
            } else if (face === 'U') {
                if (horizontal) {
                    if (row === 0) { moveToExecute = 'B'; counterClockwise = deltaX > 0; }
                    else if (row === 2) { moveToExecute = 'F'; counterClockwise = deltaX < 0; }
                } else {
                    if (col === 0) { moveToExecute = 'L'; counterClockwise = deltaY < 0; }
                    else if (col === 2) { moveToExecute = 'R'; counterClockwise = deltaY < 0; }
                }
            } else if (face === 'R') {
                if (horizontal) {
                    if (row === 0) { moveToExecute = 'U'; counterClockwise = deltaX > 0; }
                    else if (row === 2) { moveToExecute = 'D'; counterClockwise = deltaX < 0; }
                } else {
                    if (col === 0) { moveToExecute = 'F'; counterClockwise = deltaY < 0; }
                    else if (col === 2) { moveToExecute = 'B'; counterClockwise = deltaY > 0; }
                }
            }

            if (moveToExecute) {
                rotateFace(moveToExecute, counterClockwise);
            }
        }

        function rotateFace(face, counterClockwise = false) {
            incrementMoves();

            // Guardar en historial
            const notation = face + (counterClockwise ? "'" : '');
            moveHistory.push({ face, counterClockwise, notation });
            addToHistory(notation);

            const temp = JSON.parse(JSON.stringify(cubeState));

            // Animar la cara
            animateFaceRotation(face, counterClockwise);

            // Rotar la cara
            if (!counterClockwise) {
                cubeState[face] = [
                    temp[face][6], temp[face][3], temp[face][0],
                    temp[face][7], temp[face][4], temp[face][1],
                    temp[face][8], temp[face][5], temp[face][2]
                ];
            } else {
                cubeState[face] = [
                    temp[face][2], temp[face][5], temp[face][8],
                    temp[face][1], temp[face][4], temp[face][7],
                    temp[face][0], temp[face][3], temp[face][6]
                ];
            }

            // Algoritmo completo de rotaci√≥n (igual que antes)
            applyRotationAlgorithm(face, counterClockwise, temp);

            updateCubeUI();
            updateCubeUI(miniCube, cubeState);
            checkSolved();
        }

        function animateFaceRotation(face, counterClockwise) {
            const faceElement = cube.querySelector(`[data-face="${face}"]`);
            faceElement.classList.add('rotating');
            setTimeout(() => faceElement.classList.remove('rotating'), 400);
        }

        function applyRotationAlgorithm(face, ccw, temp) {
            // Implementaci√≥n completa del algoritmo (ya lo tienes del archivo anterior)
            if (face === 'U') {
                if (!ccw) {
                    [cubeState.F[0], cubeState.F[1], cubeState.F[2], cubeState.R[0], cubeState.R[1], cubeState.R[2], cubeState.B[0], cubeState.B[1], cubeState.B[2], cubeState.L[0], cubeState.L[1], cubeState.L[2]] =
                    [temp.R[0], temp.R[1], temp.R[2], temp.B[0], temp.B[1], temp.B[2], temp.L[0], temp.L[1], temp.L[2], temp.F[0], temp.F[1], temp.F[2]];
                } else {
                    [cubeState.F[0], cubeState.F[1], cubeState.F[2], cubeState.L[0], cubeState.L[1], cubeState.L[2], cubeState.B[0], cubeState.B[1], cubeState.B[2], cubeState.R[0], cubeState.R[1], cubeState.R[2]] =
                    [temp.L[0], temp.L[1], temp.L[2], temp.B[0], temp.B[1], temp.B[2], temp.R[0], temp.R[1], temp.R[2], temp.F[0], temp.F[1], temp.F[2]];
                }
            }
            // ... implementar D, L, R, F, B igual que en versi√≥n anterior
        }

        function addToHistory(notation) {
            const li = document.createElement('li');
            li.className = 'history-item';
            li.innerHTML = `
                <span class="move-notation">${notation}</span>
                <span class="move-number">#${moves}</span>
            `;
            historyList.insertBefore(li, historyList.firstChild);

            // Limitar historial a 20 items
            while (historyList.children.length > 20) {
                historyList.removeChild(historyList.lastChild);
            }
        }

        function undoMove() {
            if (moveHistory.length === 0) return;

            const lastMove = moveHistory.pop();
            rotateFace(lastMove.face, !lastMove.counterClockwise);

            // Remover del contador y del historial UI
            moves -= 2; // Porque rotateFace incrementa
            if (moves < 0) moves = 0;
            document.getElementById('moves').textContent = moves;

            if (historyList.firstChild) historyList.removeChild(historyList.firstChild);
            if (historyList.firstChild) historyList.removeChild(historyList.firstChild);
        }

        function shuffleCube() {
            resetMoves();
            resetTimer();
            historyList.innerHTML = '';
            moveHistory.length = 0;

            const movesArr = ['U', 'D', 'L', 'R', 'F', 'B'];
            for (let i = 0; i < 25; i++) {
                const randomMove = movesArr[Math.floor(Math.random() * movesArr.length)];
                const randomDir = Math.random() > 0.5;
                rotateFace(randomMove, randomDir);
            }

            resetMoves();
            historyList.innerHTML = '';
            moveHistory.length = 0;
            document.getElementById('status').textContent = '¬°Empieza!';
        }

        function resetCube() {
            Object.keys(SOLVED_STATE).forEach(face => {
                cubeState[face] = [...SOLVED_STATE[face]];
            });
            updateCubeUI();
            updateCubeUI(miniCube, cubeState);
            resetMoves();
            resetTimer();
            historyList.innerHTML = '';
            moveHistory.length = 0;
            checkSolved();
        }

        function checkSolved() {
            const solved = Object.keys(cubeState).every(face => {
                return cubeState[face].every(color => color === cubeState[face][0]);
            });

            if (solved && moves > 0) {
                stopTimer();
                document.getElementById('status').textContent = '¬°RESUELTO!';
                document.getElementById('status').className = 'status-value status-solved';
                setTimeout(() => {
                    alert(`üéâ ¬°Incre√≠ble! Resolviste el cubo en ${moves} movimientos y ${document.getElementById('timer').textContent}`);
                }, 500);
            }
        }

        function startTimer() {
            if (timerInterval) return;
            isPlaying = true;
            document.getElementById('status').textContent = 'Jugando';

            timerInterval = setInterval(() => {
                seconds++;
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                document.getElementById('timer').textContent =
                    `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function resetTimer() {
            stopTimer();
            seconds = 0;
            document.getElementById('timer').textContent = '00:00';
            isPlaying = false;
            document.getElementById('status').textContent = 'Listo';
        }

        function incrementMoves() {
            if (!isPlaying && moves === 0) startTimer();
            moves++;
            document.getElementById('moves').textContent = moves;
        }

        function resetMoves() {
            moves = 0;
            document.getElementById('moves').textContent = '0';
        }

        function updateCubeRotation() {
            cube.style.transform = `rotateX(${currentRotationX}deg) rotateY(${currentRotationY}deg)`;
        }

        // Initialize
        createCube(cube);
        createCube(miniCube, true);
        updateCubeUI();
        updateCubeUI(miniCube, cubeState);
        updateCubeRotation();
    </script>
</body>
</html>
